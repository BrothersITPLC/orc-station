from datetime import datetime, timedelta
from decimal import Decimal

from django.core.exceptions import ValidationError
from django.db.models import Case, Count, F, Q, Subquery, Sum
from django.db.models import Value as V
from django.db.models import When
from django.db.models.functions import Coalesce, Concat
from django.utils.timezone import make_aware
from rest_framework import permissions, status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response

from analysis.views.helpers import (
    annotate_revenue_on_checkins,
    parse_and_validate_date_range,
)
from declaracions.models import Checkin
from users.models import CustomUser, Report
from workstations.models import WorkStation

# @api_view(["GET"])
# @permission_classes([permissions.AllowAny])
# def admin_revenue_and_issues_report(request):
#     """
#     Generates a report for administrators detailing collected revenue and
#     issue counts per employee (controller) across all workstations within
#     a specified date range.

#     This endpoint filters check-ins and reports by the provided date range.
#     It iterates through all workstations and their associated employees,
#     calculating the total incremental revenue generated by each employee
#     and counting the number of issues (reports) they submitted.
#     `parse_and_validate_date_range` handles robust date validation, and
#     `annotate_revenue_on_checkins` efficiently calculates revenue at the
#     database level, replacing manual Python loops.

#     Query Parameters:
#     - selected_date_type (str): The type of date range validation ('weekly', 'monthly', 'yearly'). Required.
#     - start_date (str, YYYY-MM-DD): The start date for filtering check-ins and reports. Required.
#     - end_date (str, YYYY-MM-DD): The end date for filtering check-ins and reports. Required.

#     Returns:
#         Response: A list of dictionaries, where each dictionary represents an employee
#         with their name, workstation, collected revenue, and issue count.
#         The list is sorted by 'Collected Revenue' in descending order.
#         Example:
#         [
#             {"Name": "John Doe", "Station": "Main Station", "Collected Revenue": 12345.67, "Issue Count": 5},
#             {"Name": "Jane Smith", "Station": "Station B", "Collected Revenue": 8901.23, "Issue Count": 2},
#             ...
#         ]

#     Raises:
#         HTTP 400 Bad Request: If any required parameters are missing, date formats are invalid,
#                               or the date range does not match the 'selected_date_type' rules.
#     """
#     selected_date_type = request.query_params.get("selected_date_type")
#     start_date_str = request.query_params.get("start_date")
#     end_date_str = request.query_params.get("end_date")

#     if not all([selected_date_type, start_date_str, end_date_str]):
#         missing_params = [
#             param_name
#             for param_name, param_value in {
#                 "selected_date_type": selected_date_type,
#                 "start_date": start_date_str,
#                 "end_date": end_date_str,
#             }.items()
#             if not param_value
#         ]
#         return Response(
#             {"error": f"Missing required parameters: {', '.join(missing_params)}."},
#             status=status.HTTP_400_BAD_REQUEST,
#         )

#     try:
#         start_date, inclusive_end_date = parse_and_validate_date_range(
#             start_date_str, end_date_str, selected_date_type
#         )
#     except ValidationError as e:
#         return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

#     common_filters = Q(
#         checkin_time__range=[start_date, inclusive_end_date],
#         status__in=["pass", "paid", "success"],
#         employee__isnull=False,
#         station__isnull=False,
#     )

#     annotated_checkins_with_revenue = annotate_revenue_on_checkins(
#         Checkin.objects.filter(common_filters)
#     )

#     revenue_aggregates = (
#         annotated_checkins_with_revenue.values(
#             "employee__id",
#             "station__id",
#         )
#         .annotate(
#             employee_full_name=Concat(
#                 F("employee__first_name"), V(" "), F("employee__last_name")
#             ),
#             station_name=F("station__name"),
#             collected_revenue=Coalesce(Sum("revenue"), Decimal(0)),
#         )
#         .order_by("employee__id", "station__id")
#     )

#     employee_ids_with_revenue = revenue_aggregates.values_list(
#         "employee__id", flat=True
#     ).distinct()
#     station_ids_with_revenue = revenue_aggregates.values_list(
#         "station__id", flat=True
#     ).distinct()

#     issue_aggregates = (
#         Report.objects.filter(
#             employee_id__in=employee_ids_with_revenue,
#             station_id__in=station_ids_with_revenue,
#             created_at__range=[start_date, inclusive_end_date],
#         )
#         .values("employee__id", "station__id")
#         .annotate(issue_count=Coalesce(Count("id"), 0))
#     )

#     issues_lookup = {
#         (item["employee__id"], item["station__id"]): item["issue_count"]
#         for item in issue_aggregates
#     }

#     result = []
#     for revenue_item in revenue_aggregates:
#         employee_id = revenue_item["employee__id"]
#         station_id = revenue_item["station__id"]

#         issue_count = issues_lookup.get((employee_id, station_id), 0)

#         result.append(
#             {
#                 "Name": revenue_item["employee_full_name"],
#                 "Station": revenue_item["station_name"],
#                 "Collected Revenue": float(round(revenue_item["collected_revenue"], 2)),
#                 "Issue Count": issue_count,
#             }
#         )

#     result.sort(key=lambda x: x["Collected Revenue"], reverse=True)

#     return Response(result)


@api_view(["GET"])
@permission_classes([permissions.AllowAny])
def admin_revenue_and_issues_report(request):
    """
    Generates a report for administrators detailing collected revenue and
    issue counts per employee (controller) across all workstations within
    a specified date range.
    """
    selected_date_type = request.query_params.get("selected_date_type")
    start_date_str = request.query_params.get("start_date")
    end_date_str = request.query_params.get("end_date")

    if not all([selected_date_type, start_date_str, end_date_str]):
        missing_params = [
            param_name
            for param_name, param_value in {
                "selected_date_type": selected_date_type,
                "start_date": start_date_str,
                "end_date": end_date_str,
            }.items()
            if not param_value
        ]
        return Response(
            {"error": f"Missing required parameters: {', '.join(missing_params)}."},
            status=status.HTTP_400_BAD_REQUEST,
        )

    try:
        start_date, inclusive_end_date = parse_and_validate_date_range(
            start_date_str, end_date_str, selected_date_type
        )
    except ValidationError as e:
        return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

    common_filters = Q(
        checkin_time__range=[start_date, inclusive_end_date],
        status__in=["pass", "paid", "success"],
        employee__isnull=False,
        station__isnull=False,
    )

    # First, get the checkins with revenue annotation
    annotated_checkins_with_revenue = annotate_revenue_on_checkins(
        Checkin.objects.filter(common_filters)
    )

    # Convert to list of dictionaries to avoid window function in aggregation
    checkins_data = list(
        annotated_checkins_with_revenue.values(
            "id",
            "employee__id",
            "employee__first_name",
            "employee__last_name",
            "station__id",
            "station__name",
            "revenue",
        )
    )

    # Aggregate revenue in Python instead of database
    revenue_dict = {}
    for item in checkins_data:
        key = (item["employee__id"], item["station__id"])
        if key not in revenue_dict:
            revenue_dict[key] = {
                "employee__id": item["employee__id"],
                "station__id": item["station__id"],
                "employee_full_name": f"{item['employee__first_name']} {item['employee__last_name']}",
                "station_name": item["station__name"],
                "collected_revenue": Decimal(0),
            }
        revenue_dict[key]["collected_revenue"] += item["revenue"] or Decimal(0)

    revenue_aggregates = list(revenue_dict.values())

    # Get employee and station IDs for issue query
    employee_ids_with_revenue = [item["employee__id"] for item in revenue_aggregates]
    station_ids_with_revenue = [item["station__id"] for item in revenue_aggregates]

    issue_aggregates = (
        Report.objects.filter(
            employee_id__in=employee_ids_with_revenue,
            station_id__in=station_ids_with_revenue,
            created_at__range=[start_date, inclusive_end_date],
        )
        .values("employee__id", "station__id")
        .annotate(issue_count=Coalesce(Count("id"), 0))
    )

    issues_lookup = {
        (item["employee__id"], item["station__id"]): item["issue_count"]
        for item in issue_aggregates
    }

    result = []
    for revenue_item in revenue_aggregates:
        employee_id = revenue_item["employee__id"]
        station_id = revenue_item["station__id"]

        issue_count = issues_lookup.get((employee_id, station_id), 0)

        result.append(
            {
                "Name": revenue_item["employee_full_name"],
                "Station": revenue_item["station_name"],
                "Collected Revenue": float(round(revenue_item["collected_revenue"], 2)),
                "Issue Count": issue_count,
            }
        )

    result.sort(key=lambda x: x["Collected Revenue"], reverse=True)

    return Response(result)
